# 异步-进阶

## event loop 的机制(事件轮询/时间循环)

- JS 是单线程的

- 异步要基于回调来实现

- event loop 就是异步回调的实现原理

## event loop 的执行过程

1. 同步代码，一行行放在 Call Stack(调用栈)执行

2. 遇到异步，会先记录下，等待时机(定时任务、网络请求)

3. 时机到了，就会移动到 Callback Queue

4. 如果 Call Stack 为空(即同步代码执行完毕)`EventLoop`开始工作

5. 轮询查找 Callback Queue(回调队列)，如有则移动到 Call Stack 执行

6. 然后继续轮训查找(永动机一样)

[![2H0qiD.png](https://z3.ax1x.com/2021/06/15/2H0qiD.png)](https://imgtu.com/i/2H0qiD)

## Promise 的三种状态

- pending(等待) resolved(成功) rejected(失败)

- pending => resolved 或者 pending => rejected

- 变化不可逆, 没发把成功变成失败

```js
// 刚定义时，状态默认为 pending
const p1 = new Promise((resolve, reject) => {})

// 执行 resolve() 后，状态变成 resolved
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve()
  })
})

// 执行 reject() 后，状态变成 rejected
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject()
  })
})
```

### 状态的表现和变化

1. `pending` 状态, 不会触发 then 和 catch

2. `resolve` 状态, 会触发后续的 then 回调函数

3. `rejected` 状态, 会触发后续的 catch 回调函数

```js
// `resolve` 状态, 会触发后续的 then 回调函数
const p1 = Promise.resolve(100)
// console.log('p1', p1);

p1.then(data => {
  console.log('data', data)
}).catch(err => {
  console.log(err)
})

// `rejected` 状态, 会触发后续的 catch 回调函数
const p2 = Promise.reject('err')
// console.log('p2', p2);

p2.then(data => {
  console.log('data', data)
}).catch(err => {
  console.log(err)
})
```

## then 和 catch 改变状态

- then 和 catch 对状态的影响

1. `then` 正常返回 resolved, 里面有报错则返回 rejected

```js
// `then` 正常返回 resolved, 里面有报错则返回 rejected
const p1 = Promise.resolve().then(() => {
  return 100
})
console.log('p1', p1)
p1.then(() => {
  console.log(123)
})

const p2 = Promise.resolve().then(() => {
  throw new Error('then error')
})
console.log('p2', p2)
p2.then(() => {
  console.log(456)
}).catch(() => {
  console.log(789)
})
```

2. `catch` 正常返回 resolved, 里面有报错则返回 rejected

> 题目演示

[![cvTChF.png](https://z3.ax1x.com/2021/04/25/cvTChF.png)](https://imgtu.com/i/cvTChF)

```js
// 打印 1，3
Promise.resolve()
  .then(() => {
    console.log(1)
  })
  .catch(() => {
    console.log(2)
  })
  .then(() => {
    console.log(3)
  })

// 打印 1，2，3
Promise.resolve()
  .then(() => {
    console.log(1)
    throw new Error('err')
  })
  .catch(() => {
    console.log(2)
  })
  .then(() => {
    console.log(3)
  })

// 打印 1，2
Promise.resolve()
  .then(() => {
    console.log(1)
    throw new Error('err')
  })
  .catch(() => {
    console.log(2)
  })
  .catch(() => {
    console.log(3)
  })
```

```js
// then() 一般正常返回 resolved  状态的 promise
Promise.resolve().then(() => {
  return 100
})

// then() 里抛出错误，会返回 rejected 状态的 promise
Promise.resolve().then(() => {
  throw new Error('err')
})
```

## async/await

- 异步回调地域(场景)

- Promise, then, catch 是链式调用, 但也是基于回调函数

- async/await 是同步语法, 彻底消灭回调函数

## async/await 和 Promise 的关系

- 执行 async 函数, 返回的是 Promise 对象

- await 相当于 Promise 的 then

- try...catch 可以捕获异常, 代替了 Promise 的 catch
