# 循环队列

因为在循环队列情况下，到了数组的末端还可以返回回来(数组的前端)，这是靠求余这个操作

## 循环队列的实现

> 写循环队列的时候，一定要注意`front`和`tail`值变化，要让他们循环起来

- java

```java
public class LoopQueue<E> implements Queue<E> {
  // 循环队列
  private E[] data;
  private int front, tail, size;

  public LoopQueue() {
    this(10);
  }

  public LoopQueue(int capacity) {
    data = (E[]) new Object[capacity];
    front = 0;
    tail = 0;
    size = 0;
  }

  public int getCapacity() {
    return data.length;
  }

  @Override
  public int getSize() {
    return size;
  }

  /**
   * 判断队列是否为空
   * 根据开始值和结尾值相等,就可以认为队列为空
   */
  @Override
  public boolean isEmpty() {
    return front == tail;
  }

  /**
   * 入队
   */
  @Override
  public void enqueue(E e) {
    // [□ b c d e]
    // 首先判断队列是不是满的,因为循环队列
    // % data.length 要让整个队列的索引循环起来
    if ((tail + 1) % data.length == front) {
      resize(getCapacity() * 2);
    }
    data[tail] = e;
    size++;
    // [□ b c d □]
    // 如上情况,tail可能会为0,所以要循环起来
    tail = (tail + 1) % data.length;
  }

  /**
   * 出队
   */
  @Override
  public E dequeue() {
    if (isEmpty()) {
      throw new IllegalArgumentException("Cannot dequeue from an empty queue.");
    }
    E res = data[front];
    data[front] = null;
    // [f □ □ □ e]
    // 这种情况下, front可能会回到0, 所以出队也要这样写
    // 记住: 循环队列中, 改变front和tail的值,都需要考虑,"循环起来"这个概念
    front = (front + 1) % data.length;
    size--;
    // todo: 看看这个缩容操作
    if (size == getCapacity() / 4 && getCapacity() / 2 != 0) {
      resize(getCapacity() / 2);
    }
    return res;
  }

  /**
   * 获取栈首元素
   */
  @Override
  public E getFront() {
    if (isEmpty()) {
      throw new IllegalArgumentException("Queue is empty.");
    }
    return data[front];
  }

  @Override
  public String toString() {
    StringBuilder str = new StringBuilder();
    str.append(String.format(
      "Queue: size = %d, capacity = %d, front = %d, tail = %d\n",
      size, getCapacity(), front, tail
    ));
    str.append("front [");
    for (int i = front; i != tail; i = (i + 1) % data.length) {
      str.append(data[i]);
      // [□ b c d e] front = 1;tail = 0
      // for(int i = 1;i != 0;i = (i + 1) % 5)
      // 当 i = 4的时候,到了e,说明是最后一个了,不需要加逗号
      if ((i + 1) % data.length != tail) {
        str.append(", ");
      }
    }
    str.append("] tail");
    return str.toString();
  }

  /**
   * 扩容数组
   */
  private void resize(int capacity) {
    E[] newData = (E[]) new Object[capacity];
    for (int i = 0; i < size; i++) {
      newData[i] = data[(front + i) % data.length];
    }
    data = newData;
    front = 0;
    tail = size;
  }

  public static void main(String[] args) {
    LoopQueue<Integer> queue = new LoopQueue<>(5);
    for (int i = 0; i < 10; i++) {
      queue.enqueue(i);
      System.out.println(queue);
      if (i % 3 == 2) {
        System.out.println("index = " + i);
        queue.dequeue();
        System.out.println(queue);
      }
    }
  }
}

```

- js

```ts
interface IQueue<E> {
  // 这两种定义,有什么区别
  isEmpty: () => boolean
  dequeue: () => E

  enqueue(e: E): void

  getFront(): E

  getSize(): number
}

class LoopQueue<E> implements IQueue<E> {
  private data: E[]
  private front: number
  private tail: number
  private size: number

  constructor(capacity: number = 10) {
    this.data = new Array(capacity)
    this.front = 0
    this.tail = 0
    this.size = 0
  }

  /**
   * 获取容量大小
   */
  public getCapacity(): number {
    return this.data.length
  }

  public getSize(): number {
    return this.size
  }

  public dequeue(): E {
    if (this.isEmpty()) {
      throw new Error('Cannot dequeue from an empty queue.')
    }
    const { tail, front, data } = this
    const res: E = data[front]
    data[front] = null
    this.front = (front + 1) % data.length
    this.size--
    if (this.size === this.getCapacity() / 4 && this.getCapacity() / 2 !== 0) {
      this.resize(this.getCapacity() / 2)
    }
    return res
  }

  public enqueue(e: E): void {
    // 判断队列是不是满了,满了则需要resize
    const { tail, front, data } = this
    if ((tail + 1) % data.length === front) {
      this.resize(this.getCapacity() * 2)
    }
    this.data[this.tail] = e
    this.tail = (this.tail + 1) % this.data.length
    this.size++
  }

  public getFront(): E {
    if (this.isEmpty()) {
      throw new Error('Queue is empty.')
    }
    return this.data[this.front]
  }

  public isEmpty(): boolean {
    return this.tail === this.front
  }

  public toString(): string {
    const { front, data, size, tail } = this
    let str = `Queue: size = ${
      this.size
    }, capacity = ${this.getCapacity()}, front = ${this.front}, tail = ${
      this.tail
    }\n`
    str += 'front ['
    for (let i = front; i !== tail; i = (i + 1) % data.length) {
      str += data[i]
      // [□ b c d e] front = 1;tail = 0
      // for(int i = 1;i != 0;i = (i + 1) % 5)
      // 当 i = 4的时候,到了e,说明是最后一个了,不需要加逗号
      if ((i + 1) % data.length !== tail) {
        str += ', '
      }
    }
    str += '] tail'
    return str
  }

  private resize(capacity: number): void {
    const newData: E[] = new Array(capacity)
    const { front, data, size } = this
    for (let i = 0; i < size; i++) {
      newData[i] = data[(front + i) % data.length]
    }
    this.data = newData
    this.front = 0
    this.tail = this.size
  }
}

const queue = new LoopQueue(5)
for (let i = 0; i < 10; i++) {
  queue.enqueue(i)
  console.log(queue.toString())
  if (i % 3 === 2) {
    queue.dequeue()
    console.log(queue.toString())
  }
}
```
